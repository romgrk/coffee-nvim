// Generated by CoffeeScript 1.10.0
(function() {
  var Nvim, Reflect, accessors, await, defer, fiber, lib, sync,
    slice = [].slice;

  Reflect = require('harmony-reflect');

  sync = require('synchronize');

  fiber = sync.fiber;

  await = sync.await;

  defer = sync.defer;

  Nvim = null;

  module.exports = function(nvim) {
    var desc, property;
    Nvim = nvim;
    for (property in accessors) {
      desc = accessors[property];
      Object.defineProperty(lib, property, desc);
    }
    return lib;
  };

  accessors = {
    windows: {
      get: function() {
        return Nvim.getWindows();
      }
    },
    buffers: {
      get: function() {
        return Nvim.getBuffers();
      }
    },
    buffer: {
      get: function() {
        return Nvim.getCurrentBuffer().getProxy();
      },
      set: function(b) {
        return Nvim.setCurrentBuffer(b);
      }
    },
    window: {
      get: function() {
        return Nvim.getCurrentWindow().getProxy();
      },
      set: function(b) {
        return Nvim.setCurrentWindow(b);
      }
    },
    tabpage: {
      get: function() {
        return Nvim.getCurrentTabpage().getProxy();
      },
      set: function(b) {
        return Nvim.setCurrentTabpage(b);
      }
    }
  };

  lib = {};

  lib.echo = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return Nvim.command("echo '" + (args.join(' ').replace(/[\\']/g, '$&')) + "'");
  };

  lib.echon = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return Nvim.command("echon '" + (args.join(' ').replace(/[\\']/g, '$&')) + "'");
  };

  lib.echohl = function() {
    var args, hl, msg;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (args.length === 0) {
      return;
    }
    hl = args[0];
    if (args.length === 1) {
      return Nvim.command("echohl " + hl);
    } else {
      msg = args.slice(1).join(' ');
      Nvim.command("echohl " + hl);
      Nvim.command("echo '" + msg + "'");
      return Nvim.command("echohl None");
    }
  };

  lib.echonhl = function() {
    var args, hl, msg;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (args.length === 0) {
      return;
    }
    hl = args[0];
    if (args.length === 1) {
      return Nvim.command("echohl " + hl);
    } else {
      msg = args.slice(1).join(' ');
      Nvim.command("echohl " + hl);
      Nvim.command("echon '" + msg + "'");
      return Nvim.command("echohl None");
    }
  };

  lib.bufnr = function(expr) {
    return Nvim["eval"]("bufnr('" + expr + "')");
  };

  lib.bufname = function(nr) {
    return Nvim["eval"]("bufname(" + nr + ")").toString();
  };

  lib.set = function(option, value) {
    if (option == null) {
      return;
    }
    if (option.slice(-1) === '?') {
      return await(Nvim.getOption(option.slice(0, -1), defer()));
    }
    if (value != null) {
      return Nvim.setOption(option, value);
    }
  };

  lib.normal = function(seq, nore) {
    if (nore == null) {
      nore = true;
    }
    return Nvim.command("normal" + (typeof nore === "function" ? nore({
      '!': ''
    }) : void 0) + " " + seq);
  };

  lib.execute = function(seq) {
    return Nvim.command(seq);
  };

  lib.call = function() {
    var args, fname;
    fname = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return Nvim.callFunction(fname, args != null ? args : []);
  };

  lib.input = function(keys) {
    return Nvim.input(keys);
  };

  lib.feedkeys = function() {
    var args, ref, ref1;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return Nvim.feedkeys(args[0], (ref = args[1]) != null ? ref : 'n', (ref1 = args[2]) != null ? ref1 : false);
  };

  lib.insert = function(lnum, lines) {
    var buf;
    buf = Nvim.getCurrentBuffer();
    return buf.insert(lnum, lines);
  };

}).call(this);
