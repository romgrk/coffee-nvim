// Generated by CoffeeScript 1.10.0
(function() {
  var Path, await, context, defer, fiber, properties, sync,
    slice = [].slice;

  Path = require('path');

  sync = require('../dev/sync');

  fiber = sync.fiber;

  await = sync.await;

  defer = sync.defer;

  module.exports = context = {};

  properties = {
    windows: {
      get: function() {
        return await(Nvim.getWindows(defer()));
      }
    },
    buffers: {
      get: function() {
        return await(Nvim.getBuffers(defer()));
      }
    },
    buffer: {
      get: function() {
        return await(Nvim.getCurrentBuffer(defer()));
      },
      set: function(b) {
        return Nvim.setCurrentBuffer(b);
      }
    },
    window: {
      get: function() {
        return await(Nvim.getCurrentWindow(defer()));
      },
      set: function(b) {
        return Nvim.setCurrentWindow(b);
      }
    },
    tab: {
      get: function() {
        return await(Nvim.getCurrentTabpage(defer()));
      },
      set: function(b) {
        return Nvim.setCurrentTabpage(b);
      }
    }
  };

  context.init = function() {
    var BufferPrototype, def, definition, k, key, ref, results;
    for (key in properties) {
      definition = properties[key];
      Object.defineProperty(context, key, definition);
    }
    BufferPrototype = Object.getPrototypeOf(context.buffer);
    ref = context.Buffer;
    results = [];
    for (k in ref) {
      def = ref[k];
      results.push(Object.defineProperty(BufferPrototype, k, def));
    }
    return results;
  };

  context.echo = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return Nvim.command("echo '" + (args.join('')) + "'");
  };

  context.echohl = function() {
    var args, hl, msg;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    hl = args.length === 1 ? 'TextInfo' : args[0];
    msg = args.length === 1 ? args[0] : args.slice(1).join(' ');
    return Nvim.command("EchoHL " + hl + " " + msg);
  };

  context["eval"] = function(text) {
    return await(Nvim["eval"](text, defer()));
  };

  context.bufnr = function(expr) {
    return await(Nvim["eval"]("bufnr('" + expr + "')", defer()));
  };

  context.bufname = function(nr) {
    return await(Nvim["eval"]("bufname(" + nr + ")", defer())).toString();
  };

  context.set = function(option, value) {
    if (option == null) {
      return;
    }
    if (option.slice(-1) === '?') {
      return await(Nvim.getOption(option.slice(0, -1), defer()));
    }
    if (value != null) {
      return Nvim.setOption(option, value);
    }
  };

  context.normal = function(seq, nore) {
    if (nore == null) {
      nore = true;
    }
    return Nvim.command("normal" + (typeof nore === "function" ? nore({
      '!': ''
    }) : void 0) + " " + seq);
  };

  context.execute = function(seq) {
    return Nvim.command(seq);
  };

  context.insert = function(lnum, lines) {
    var buf;
    buf = await(Nvim.getCurrentBuffer(defer()));
    return buf.insert(lnum, lines);
  };

  context.Buffer = {
    length: {
      get: function() {
        return await(this.lineCount(defer()));
      }
    },
    number: {
      get: function() {
        return await(this.getNumber(defer()));
      }
    },
    name: {
      get: function() {
        return await(this.getName(defer()));
      },
      set: function(v) {
        return this.setName(v);
      }
    }
  };

}).call(this);
