// Generated by CoffeeScript 1.10.0
(function() {
  var CoffeeScript, Fs, Logger, Net, Nvim, PORT, Path, Plugin, Reflect, Vm, _, attach, await, callHandler, coffeelib, commands, dataHandler, defer, defineCommand, fiber, getSpecs, hostSetup, loaded, log, onNvimDisconnect, onNvimNotification, onNvimRequest, sock, stdio, sync, util, vmHandler,
    slice = [].slice;

  _ = require('lodash');

  Net = require('net');

  Path = require('path');

  Fs = require('fs');

  Vm = require('vm');

  CoffeeScript = require('coffee-script');

  Reflect = require('harmony-reflect');

  attach = require('neovim-client');

  Logger = require('romgrk-logger');

  util = require('util');

  Plugin = require('./plugin');

  sync = require('synchronize');

  fiber = sync.fiber;

  await = sync.await;

  defer = sync.defer;

  stdio = [process.stdout, process.stdin];

  PORT = 5000;

  sock = null;

  Nvim = null;

  coffeelib = null;

  loaded = false;

  commands = {};

  dataHandler = function(data) {
    var code, e, error;
    data = data.toString().trim();
    try {
      code = CoffeeScript.compile(data, {
        bare: true
      });
    } catch (error) {
      e = error;
      log.error(e.stack);
      return;
    }
    return fiber(function() {
      return vmHandler(code);
    });
  };

  vmHandler = function(code) {
    var context, e, error, res, sandbox;
    try {
      context = coffeelib;
      context._ = _;
      context.log = log;
      context.sync = sync;
      context.require = require;
      context.process = process;
      sandbox = Vm.createContext(context);
      res = Vm.runInContext(code, sandbox);
      if (res != null) {
        if (typeof res === 'object') {
          return log.debug(util.inspect(res, {
            depth: 1
          }));
        } else {
          return log.debug(res);
        }
      }
    } catch (error) {
      e = error;
      return log.error(e, e.stack);
    }
  };

  onNvimNotification = function(method, args) {
    log.info('Notification: ', method, args.toString());
    if (method === '') {
      return;
    }
    if (commands[method] != null) {
      return fiber(function() {
        return commands[method].apply(commands, args);
      });
    } else {
      return fiber(function() {
        return callHandler(method, args);
      });
    }
  };

  onNvimRequest = function(method, args, resp) {
    var e, error;
    if (method === 'poll') {
      resp.send('ok');
      return;
    }
    if (method === 'specs') {
      getSpecs(args[0], resp);
      return;
    }
    log.info('Request: ', method, args.toString());
    try {
      callHandler(method, args, resp);
    } catch (error) {
      e = error;
      log.error(e.stack);
      return resp.send(e.toString(), true);
    }
    return resp.send('noaction', true);
  };

  onNvimDisconnect = function() {
    return log.error('Nvim session closed');
  };

  callHandler = function(method, args, resp) {
    var data, e, error, filename, handler, plugin, rest, rv;
    data = method.split(':');
    filename = data[0];
    rest = data.slice(1).join(':');
    try {
      plugin = Plugin._load(filename);
      if (plugin != null) {
        handler = plugin.handlers[rest];
        rv = handler.apply(plugin, args);
        return resp != null ? resp.send(rv) : void 0;
      } else {
        log.warning('Plugin not found: ' + filename);
        if (resp != null) {
          return resp.send('Plugin not found', true);
        }
      }
    } catch (error) {
      e = error;
      log.err(method, args, e.stack);
      if (resp != null) {
        return resp.send(e.toString(), true);
      }
    }
  };

  getSpecs = function(filename, resp) {
    var e, error, plugin;
    try {
      plugin = Plugin._load(filename);
      if (plugin != null) {
        if (plugin.specs == null) {
          plugin.specs = [];
        }
        resp.send(plugin.specs);
        return log.success('specs: ' + filename, plugin.specs);
      } else {
        return resp.send(false);
      }
    } catch (error) {
      e = error;
      resp.send(false);
      log.error('SPECS:' + filename);
      return log.error(e.stack);
    }
  };

  commands['CoffeelibPlugin'] = function(file) {
    var e, error, p;
    try {
      if (Plugin._cache[file] != null) {
        delete Plugin._cache[file];
      }
      p = new Plugin(file);
      p.load(coffeelib);
      return global.res = p.exports;
    } catch (error) {
      e = error;
      return log.error(e, e.stack);
    }
  };

  commands['CoffeelibRun'] = function(file) {
    var code, content, e, error;
    try {
      content = Fs.readFileSync(file).toString();
      code = CoffeeScript.compile(content, {
        bare: true
      });
      return vmHandler(code);
    } catch (error) {
      e = error;
      return log.error(e, e.stack);
    }
  };

  defineCommand = function(name) {
    var def;
    def = "command! " + name + " call rpcnotify(" + Nvim._channel_id + ",";
    def += " '" + name + "', expand('%:p'))";
    return Nvim.command(def);
  };

  sock = Net.createConnection(PORT);

  sock.on('data', dataHandler);

  global.log = log = Logger(console.log);

  log.method = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return sock.write(args.join(' ') + '\n');
  };

  attach(stdio[0], stdio[1], function(err, nvim) {
    var e, error;
    if (err) {
      log.error('Couldnt initiate nvim', err.stack);
      return;
    }
    try {
      return hostSetup(nvim);
    } catch (error) {
      e = error;
      return log.error('Couldnt setup host', e.stack);
    }
  });

  hostSetup = function(nvim) {
    var c, results;
    global.Nvim = Nvim = nvim;
    Nvim.on('request', onNvimRequest);
    Nvim.on('notification', onNvimNotification);
    Nvim.on('disconnect', onNvimDisconnect);
    coffeelib = require('./coffeelib');
    coffeelib.log = log;
    Plugin._context = coffeelib;
    log.success('connected to neovim, channel=' + Nvim._channel_id);
    loaded = true;
    results = [];
    for (c in commands) {
      log.info('Defining ' + c);
      results.push(defineCommand(c));
    }
    return results;
  };

}).call(this);
