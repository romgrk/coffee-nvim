// Generated by CoffeeScript 1.10.0
(function() {
  var Fs, Logger, Net, Nvim, PORT, Path, Plugin, Reflect, Vm, _, argv, attach, await, callHandler, clib, coffee, commands, dataHandler, defer, defineCommand, evalHandler, evalMethod, fiber, getSpecs, lib, log, nvimSocket, onNvimDisconnect, onNvimNotification, onNvimRequest, sock, stdio, sync, vmHandler,
    slice = [].slice;

  _ = require('lodash');

  Net = require('net');

  Path = require('path');

  Fs = require('fs');

  Vm = require('vm');

  attach = require('neovim-client');

  Reflect = require('harmony-reflect');

  Logger = require('romgrk-logger');

  Plugin = require('./plugin');

  coffee = require('../dev/compile');

  sync = require('../dev/sync');

  fiber = sync.fiber;

  await = sync.await;

  defer = sync.defer;

  argv = require('minimist')(process.argv.slice(2));

  log = Logger(console.log);

  if (argv.s == null) {
    argv.s = false;
  }

  PORT = 5000;

  sock = Net.createConnection(PORT);

  Nvim = null;

  lib = null;

  clib = null;

  commands = {};

  evalMethod = null;

  stdio = [process.stdout, process.stdin];

  if (argv.s === true) {
    nvimSocket = Net.createConnection({
      port: 6666
    });
    stdio = [nvimSocket, nvimSocket];
  }

  dataHandler = function(data) {
    if (evalMethod == null) {
      evalMethod = evalHandler;
    }
    data = data.toString().trim();
    if (data === 'vm') {
      log.info('Evaluating with vm');
      evalMethod = vmHandler;
      return;
    }
    if (data === 'eval') {
      log.info('Evaluating with eval');
      evalMethod = evalHandler;
      return;
    }
    return coffee(data, function(status, code) {
      if (status === 0) {
        return fiber(function() {
          return evalMethod(code);
        });
      } else {
        return log.error('couldnt compile: ', data);
      }
    });
  };

  vmHandler = function(code) {
    return fiber(function() {
      var context, e, error, sandbox;
      try {
        context = clib;
        context._ = _;
        context.log = log;
        context.sync = sync;
        context.require = require;
        sandbox = Vm.createContext(context);
        Vm.runInContext(code, sandbox);
        if (sandbox.res != null) {
          return log.debug(sandbox.res);
        }
      } catch (error) {
        e = error;
        return log.error(e, e.stack);
      }
    });
  };

  evalHandler = function(code) {
    var e, error, result;
    try {
      result = eval(code);
      if (typeof result === 'object') {
        return log.inspect(result);
      } else if (result != null) {
        return log.debug(result);
      }
    } catch (error) {
      e = error;
      return log.error(e, e.stack);
    }
  };

  onNvimNotification = function(method, args) {
    log.info('Notification: ', method, args.toString());
    if (commands[method] != null) {
      return fiber(function() {
        return commands[method].apply(commands, args);
      });
    } else {
      return fiber(function() {
        return callHandler(method, args);
      });
    }
  };

  onNvimRequest = function(method, args, resp) {
    var e, error;
    log.info('Request: ', method, args.toString());
    try {
      if (method === 'specs') {
        return getSpecs(args[0], resp);
      } else {
        callHandler(method, args, resp);
      }
    } catch (error) {
      e = error;
      log.error(e.stack);
      return resp.send(e.toString(), true);
    }
    return resp.send('noaction', true);
  };

  onNvimDisconnect = function() {
    return log.error('Nvim session closed');
  };

  callHandler = function(method, args, resp) {
    var data, e, error, filename, handler, plugin, rest, rv;
    data = method.split(':');
    filename = data[0];
    rest = data.slice(1);
    try {
      plugin = Plugin._load(filename);
      if (plugin != null) {
        handler = plugin.handler[rest];
        rv = handler.apply(plugin, args);
        return resp.send(rv);
      } else {
        log.warning('Plugin not found: ' + filename);
        if (resp != null) {
          return resp.send('Plugin not found', true);
        }
      }
    } catch (error) {
      e = error;
      log.err(method, args, e.stack);
      if (resp != null) {
        return resp.send(e.toString(), true);
      }
    }
  };

  getSpecs = function(filename, resp) {
    var e, error, plugin, ref;
    try {
      log.success('specs: ' + filename);
      plugin = Plugin._load(filename);
      log.inspect(plugin);
      if (plugin != null) {
        return resp.send((ref = plugin.specs) != null ? ref : []);
      }
    } catch (error) {
      e = error;
      log.error(e.stack);
      return resp.send(e.toString(), true);
    }
    return resp.send('Coffee-nvim: file found: ' + filename, true);
  };

  commands['CoffeePlugin'] = function(file) {
    var e, error, p;
    try {
      if (Plugin._cache[file] != null) {
        delete Plugin._cache[file];
      }
      p = new Plugin(file);
      p.load(lib.context);
      return global.res = p.exports;
    } catch (error) {
      e = error;
      return log.error(e, e.stack);
    }
  };

  commands['RunBufferInVM'] = function(file) {
    var code, content, e, error, ref, status;
    try {
      content = Fs.readFileSync(file);
      ref = coffee(content), status = ref[0], code = ref[1];
      if (status === 0) {
        vmHandler(code);
      }
      if (status === 1) {
        throw new Error("couldnt compile " + file);
      }
    } catch (error) {
      e = error;
      return log.error(e, e.stack);
    }
  };

  commands['RunBuffer'] = function(file) {
    var code, content, e, error, ref, status;
    try {
      content = Fs.readFileSync(file);
      ref = coffee(content), status = ref[0], code = ref[1];
      if (status === 0) {
        evalHandler(code);
      }
      if (status === 1) {
        throw new Error("couldnt compile " + file);
      }
    } catch (error) {
      e = error;
      return log.error(e, e.stack);
    }
  };

  defineCommand = function(name) {
    var def;
    def = "com! " + name + " call rpcnotify(" + Nvim._channel_id + ", '" + name + "', expand('%:p'))";
    return Nvim.command(def);
  };

  sock.on('data', dataHandler);

  log.method = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return sock.write(args.join(' ') + '\n');
  };

  fiber(function() {
    var e, error;
    Nvim = await(attach(stdio[0], stdio[1], defer()));
    if (Nvim instanceof Error) {
      log.error(Nvim.stack);
      process.exit(1);
    }
    global.log = log;
    log.success('connected to neovim, channel=' + Nvim._channel_id);
    Nvim.on('request', onNvimRequest);
    Nvim.on('notification', onNvimNotification);
    Nvim.on('disconnect', onNvimDisconnect);
    try {
      lib = require('./nvim');
      clib = lib.init(Nvim);
      clib.log = log;
      return Plugin._context = lib.context;
    } catch (error) {
      e = error;
      return log.error(e.stack);
    }
  });

}).call(this);
