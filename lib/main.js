// Generated by CoffeeScript 1.10.0
(function() {
  var Fs, Logger, Net, Nvim, PORT, Path, Reflect, Vm, _, argv, attach, await, coffee, dataHandler, defer, defineHandler, evalHandler, evalMethod, fiber, handlers, lib, log, nvimSocket, onNvimNotification, onNvimRequest, sock, stdio, sync, vmHandler,
    slice = [].slice;

  _ = require('lodash');

  Net = require('net');

  Path = require('path');

  Fs = require('fs');

  Vm = require('vm');

  attach = require('neovim-client');

  Reflect = require('harmony-reflect');

  Logger = require('romgrk-logger');

  coffee = require('../dev/compile');

  sync = require('../dev/sync');

  fiber = sync.fiber;

  await = sync.await;

  defer = sync.defer;

  argv = require('minimist')(process.argv.slice(2));

  log = Logger(console.log);

  if (argv.s == null) {
    argv.s = false;
  }

  PORT = 5000;

  sock = Net.createConnection(PORT);

  Nvim = null;

  lib = null;

  handlers = {};

  evalMethod = null;

  stdio = [process.stdout, process.stdin];

  if (argv.s === true) {
    nvimSocket = Net.createConnection({
      port: 6666
    });
    stdio = [nvimSocket, nvimSocket];
  }

  dataHandler = function(data) {
    if (evalMethod == null) {
      evalMethod = evalHandler;
    }
    data = data.toString().trim();
    if (data === 'vm') {
      log.info('Evaluating with vm');
      evalMethod = vmHandler;
      return;
    }
    if (data === 'eval') {
      log.info('Evaluating with eval');
      evalMethod = evalHandler;
      return;
    }
    return coffee(data, function(status, code) {
      if (status === 0) {
        return fiber(function() {
          return evalMethod(code);
        });
      } else {
        return log.error('couldnt compile: ', data);
      }
    });
  };

  vmHandler = function(code) {
    var context, e, error, sandbox;
    try {
      context = require('./nvim');
      context.log = log;
      context.sync = sync;
      context.Nvim = Nvim;
      _.extend(context, global);
      sandbox = Vm.createContext(context);
      return fiber(function() {
        Vm.runInContext(code, context);
        if (sandbox.res != null) {
          return log.debug(sandbox.res);
        }
      });
    } catch (error) {
      e = error;
      return log.error(e, e.stack);
    }
  };

  evalHandler = function(code) {
    var e, error, result;
    try {
      result = eval(code);
      if (typeof result === 'object') {
        return log.inspect(result);
      } else if (result != null) {
        return log.debug(result);
      }
    } catch (error) {
      e = error;
      return log.error(e, e.stack);
    }
  };

  onNvimNotification = function(method, args) {
    log.info('Notification: ', method, args.toString());
    if (handlers[method] != null) {
      return fiber(function() {
        return handlers[method].apply(handlers, args);
      });
    }
  };

  onNvimRequest = function(method, args, resp) {
    log.info('Request: ', method, args.toString());
    return resp.send(null);
  };

  handlers['vm'] = function(nr) {
    var code, content, e, error, file, ref, status;
    try {
      file = lib.bufname(nr);
      content = Fs.readFileSync(file);
      ref = coffee(content), status = ref[0], code = ref[1];
      if (status === 0) {
        vmHandler(code);
      }
      if (status === 1) {
        throw new Error("couldnt compile " + file);
      }
    } catch (error) {
      e = error;
      return log.error(e, e.stack);
    }
  };

  handlers['eval'] = function(nr) {
    var code, content, e, error, file, ref, status;
    try {
      file = lib.bufname(nr);
      content = Fs.readFileSync(file);
      ref = coffee(content), status = ref[0], code = ref[1];
      if (status === 0) {
        evalHandler(code);
      }
      if (status === 1) {
        throw new Error("couldnt compile " + file);
      }
    } catch (error) {
      e = error;
      return log.error(e, e.stack);
    }
  };

  defineHandler = function(c, h) {
    var def;
    def = "com! " + c + " call rpcnotify(" + Nvim._channel_id + ", '" + h + "', bufnr('%'))";
    return Nvim.command(def);
  };

  sock.on('data', dataHandler);

  log.method = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return sock.write(args.join(' ') + '\n');
  };

  log.success("lib/main running, -s=" + argv.s);

  fiber(function() {
    Nvim = await(attach(stdio[0], stdio[1], defer()));
    if (Nvim instanceof Error) {
      log.error('error connecting to neovim: ' + err);
      process.exit(1);
    }
    global.Nvim = Nvim;
    log.success('connected to neovim, channel=' + Nvim._channel_id);
    Nvim.on('request', onNvimRequest);
    Nvim.on('notification', onNvimNotification);
    lib = require('./nvim');
    lib.init();
    evalMethod = evalHandler;
    defineHandler('RunBuffer', 'eval');
    return defineHandler('RunBufferInVM', 'vm');
  });

}).call(this);
