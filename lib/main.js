// Generated by CoffeeScript 1.10.0
(function() {
  var Fs, Logger, Net, Nvim, PORT, Path, Plugin, Reflect, Vm, _, argv, attach, await, clib, coffee, dataHandler, defer, defineHandler, evalHandler, evalMethod, fiber, handlers, lib, log, nvimSocket, onNvimNotification, onNvimRequest, sock, stdio, sync, vmHandler,
    slice = [].slice;

  _ = require('lodash');

  Net = require('net');

  Path = require('path');

  Fs = require('fs');

  Vm = require('vm');

  attach = require('neovim-client');

  Reflect = require('harmony-reflect');

  Logger = require('romgrk-logger');

  Plugin = require('./plugin');

  coffee = require('../dev/compile');

  sync = require('../dev/sync');

  fiber = sync.fiber;

  await = sync.await;

  defer = sync.defer;

  argv = require('minimist')(process.argv.slice(2));

  log = Logger(console.log);

  if (argv.s == null) {
    argv.s = false;
  }

  PORT = 5000;

  sock = Net.createConnection(PORT);

  Nvim = null;

  lib = null;

  clib = null;

  handlers = {};

  evalMethod = null;

  stdio = [process.stdout, process.stdin];

  if (argv.s === true) {
    nvimSocket = Net.createConnection({
      port: 6666
    });
    stdio = [nvimSocket, nvimSocket];
  }

  dataHandler = function(data) {
    if (evalMethod == null) {
      evalMethod = evalHandler;
    }
    data = data.toString().trim();
    if (data === 'vm') {
      log.info('Evaluating with vm');
      evalMethod = vmHandler;
      return;
    }
    if (data === 'eval') {
      log.info('Evaluating with eval');
      evalMethod = evalHandler;
      return;
    }
    return coffee(data, function(status, code) {
      if (status === 0) {
        return fiber(function() {
          return evalMethod(code);
        });
      } else {
        return log.error('couldnt compile: ', data);
      }
    });
  };

  vmHandler = function(code) {
    return fiber(function() {
      var context, e, error, sandbox;
      try {
        context = clib;
        context._ = _;
        context.log = log;
        context.sync = sync;
        context.require = require;
        sandbox = Vm.createContext(context);
        Vm.runInContext(code, sandbox);
        if (sandbox.res != null) {
          return log.debug(sandbox.res);
        }
      } catch (error) {
        e = error;
        return log.error(e, e.stack);
      }
    });
  };

  evalHandler = function(code) {
    var e, error, result;
    try {
      result = eval(code);
      if (typeof result === 'object') {
        return log.inspect(result);
      } else if (result != null) {
        return log.debug(result);
      }
    } catch (error) {
      e = error;
      return log.error(e, e.stack);
    }
  };

  onNvimNotification = function(method, args) {
    log.info('Notification: ', method, args.toString());
    if (handlers[method] != null) {
      return fiber(function() {
        return handlers[method].apply(handlers, args);
      });
    }
  };

  onNvimRequest = function(method, args, resp) {
    var e, error, filename, plugin, ref;
    try {
      log.info('Request: ', method, args.toString());
      if (method === 'specs') {
        filename = args[0];
        plugin = Plugin._load(filename);
        _.extend(handlers, plugin.handlers);
        return resp.send((ref = plugin.specs) != null ? ref : []);
      } else {
        return resp.send('nop', true);
      }
    } catch (error) {
      e = error;
      log.error(e.stack);
      return resp.send(e.toString(), true);
    }
  };

  handlers['plugin'] = function(file) {
    var e, error;
    try {
      return Plugin._load(file);
    } catch (error) {
      e = error;
      return log.error(e, e.stack);
    }
  };

  handlers['vm'] = function(file) {
    var code, content, e, error, ref, status;
    try {
      content = Fs.readFileSync(file);
      ref = coffee(content), status = ref[0], code = ref[1];
      if (status === 0) {
        vmHandler(code);
      }
      if (status === 1) {
        throw new Error("couldnt compile " + file);
      }
    } catch (error) {
      e = error;
      return log.error(e, e.stack);
    }
  };

  handlers['eval'] = function(file) {
    var code, content, e, error, ref, status;
    try {
      content = Fs.readFileSync(file);
      ref = coffee(content), status = ref[0], code = ref[1];
      if (status === 0) {
        evalHandler(code);
      }
      if (status === 1) {
        throw new Error("couldnt compile " + file);
      }
    } catch (error) {
      e = error;
      return log.error(e, e.stack);
    }
  };

  defineHandler = function(c, h) {
    var def;
    def = "com! " + c + " call rpcnotify(" + Nvim._channel_id + ", '" + h + "', expand('%:p'))";
    return Nvim.command(def);
  };

  sock.on('data', dataHandler);

  log.method = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return sock.write(args.join(' ') + '\n');
  };

  fiber(function() {
    var e, error;
    Nvim = await(attach(stdio[0], stdio[1], defer()));
    if (Nvim instanceof Error) {
      log.error('error connecting to neovim: ' + err);
      process.exit(1);
    }
    global.log = log;
    log.success('connected to neovim, channel=' + Nvim._channel_id);
    Nvim.on('request', onNvimRequest);
    Nvim.on('notification', onNvimNotification);
    try {
      lib = require('./nvim');
      clib = lib.init(Nvim);
      clib.log = log;
      Plugin._context = lib.context;
    } catch (error) {
      e = error;
      log.error(e.stack);
    }
    defineHandler('RunBuffer', 'eval');
    defineHandler('RunBufferInVM', 'vm');
    return defineHandler('CoffeePlugin', 'plugin');
  });

}).call(this);
