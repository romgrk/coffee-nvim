// Generated by CoffeeScript 1.10.0
(function() {
  var CoffeeScript, Fs, Logger, Net, Nvim, PORT, Path, Plugin, Reflect, Vm, _, attach, await, callHandler, coffeelib, commands, dataHandler, defer, defineCommand, fiber, getSpecs, lib, log, onNvimDisconnect, onNvimNotification, onNvimRequest, sock, stdio, sync, vmHandler,
    slice = [].slice;

  _ = require('lodash');

  Net = require('net');

  Path = require('path');

  Fs = require('fs');

  Vm = require('vm');

  CoffeeScript = require('coffee-script');

  Reflect = require('harmony-reflect');

  attach = require('neovim-client');

  Logger = require('romgrk-logger');

  Plugin = require('./plugin');

  sync = require('synchronize');

  fiber = sync.fiber;

  await = sync.await;

  defer = sync.defer;

  stdio = [process.stdout, process.stdin];

  log = Logger();

  global.log = log;

  PORT = 5000;

  sock = Net.createConnection(PORT);

  Nvim = null;

  lib = null;

  coffeelib = null;

  commands = {};

  dataHandler = function(data) {
    var code, e, error;
    data = data.toString().trim();
    try {
      code = CoffeeScript.compile(data, {
        bare: true
      });
    } catch (error) {
      e = error;
      log.error(e.stack);
      return;
    }
    return fiber(function() {
      return vmHandler(code);
    });
  };

  vmHandler = function(code) {
    var context, e, error, res, sandbox;
    try {
      context = coffeelib;
      context._ = _;
      context.log = log;
      context.sync = sync;
      context.require = require;
      sandbox = Vm.createContext(context);
      res = Vm.runInContext(code, sandbox);
      if (res != null) {
        return log.debug(res);
      }
    } catch (error) {
      e = error;
      return log.error(e, e.stack);
    }
  };

  onNvimNotification = function(method, args) {
    log.info('Notification: ', method, args.toString());
    if (commands[method] != null) {
      return fiber(function() {
        return commands[method].apply(commands, args);
      });
    } else {
      return fiber(function() {
        return callHandler(method, args);
      });
    }
  };

  onNvimRequest = function(method, args, resp) {
    var e, error;
    log.info('Request: ', method, args.toString());
    try {
      if (method === 'specs') {
        return getSpecs(args[0], resp);
      } else {
        callHandler(method, args, resp);
      }
    } catch (error) {
      e = error;
      log.error(e.stack);
      return resp.send(e.toString(), true);
    }
    return resp.send('noaction', true);
  };

  onNvimDisconnect = function() {
    return log.error('Nvim session closed');
  };

  callHandler = function(method, args, resp) {
    var data, e, error, filename, handler, plugin, rest, rv;
    data = method.split(':');
    filename = data[0];
    rest = data.slice(1).join(':');
    try {
      plugin = Plugin._load(filename);
      if (plugin != null) {
        handler = plugin.handlers[rest];
        rv = handler.apply(plugin, args);
        return resp != null ? resp.send(rv) : void 0;
      } else {
        log.warning('Plugin not found: ' + filename);
        if (resp != null) {
          return resp.send('Plugin not found', true);
        }
      }
    } catch (error) {
      e = error;
      log.err(method, args, e.stack);
      if (resp != null) {
        return resp.send(e.toString(), true);
      }
    }
  };

  getSpecs = function(filename, resp) {
    var e, error, plugin, ref;
    try {
      log.success('specs: ' + filename);
      plugin = Plugin._load(filename);
      log.inspect(plugin);
      if (plugin != null) {
        return resp.send((ref = plugin.specs) != null ? ref : []);
      }
    } catch (error) {
      e = error;
      log.error(e.stack);
      return resp.send(e.toString(), true);
    }
    return resp.send('Coffee-nvim: file found: ' + filename, true);
  };

  commands['CoffeelibPlugin'] = function(file) {
    var e, error, p;
    try {
      if (Plugin._cache[file] != null) {
        delete Plugin._cache[file];
      }
      p = new Plugin(file);
      p.load(lib.context);
      return global.res = p.exports;
    } catch (error) {
      e = error;
      return log.error(e, e.stack);
    }
  };

  commands['CoffeelibRun'] = function(file) {
    var code, content, e, error;
    try {
      content = Fs.readFileSync(file).toString();
      code = CoffeeScript.compile(content, {
        bare: true
      });
      return vmHandler(code);
    } catch (error) {
      e = error;
      return log.error(e, e.stack);
    }
  };

  defineCommand = function(name) {
    var def;
    def = "command! " + name + " call rpcnotify(" + Nvim._channel_id + ",";
    def += " '" + name + "', expand('%:p'))";
    return Nvim.command(def);
  };

  sock.on('data', dataHandler);

  log.method = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return sock.write(args.join(' ') + '\n');
  };

  fiber(function() {
    var e, error;
    try {
      Nvim = await(attach(stdio[0], stdio[1], defer()));
      lib = require('./setup');
      coffeelib = lib.init(Nvim);
      coffeelib.log = log;
    } catch (error) {
      e = error;
      log.error('Couldnt initiate nvim', e.stack);
      process.exit(1);
    }
    log.success('connected to neovim, channel=' + Nvim._channel_id);
    Plugin._context = coffeelib;
    Nvim.on('request', onNvimRequest);
    Nvim.on('notification', onNvimNotification);
    return Nvim.on('disconnect', onNvimDisconnect);
  });

}).call(this);
